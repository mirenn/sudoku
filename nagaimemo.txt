Azureへのデプロイ
C:\Users\ngihy\Desktop\nodeserverの階層で。以下コマンドを叩く。
（古いzipがあったらそれは削除する。）
rm nodeserver.zip
rm index.js
npm run build
mv .\dist\index.js ./
Compress-Archive -Path * -DestinationPath nodeserver.zip
az webapp deploy --resource-group nagairesource --name sudokunagai --src-path C:\Users\ngihy\Desktop\nodeserver\nodeserver.zip
↑uploadscript.ps1で全て実行できる。

実行コマンド↓
npx ts-node index.ts(今はnpm run startで動くようにしている)
↓答えを作るコマンドは確か以下のような感じ。旧PCのwsl2上で実行（powershellだとどうしても出力をテキストファイルに出せなかった）
java -jar NP.jar -s .\data\Problem500.txt

参考
CSS待ち状態
https://projects.lukehaas.me/css-loaders/
数独自動生成
https://github.com/timedia/puzzle-generator

実装済み
・useridをsocket.dataに紐づける
　・もし同一userid同士の対決であれば、subuseridを用いるゲームモードにする。
再接続用の処理
　・roomIDを投げてログインしにいく
　・同じブラウザ同士時は再接続はまともに機能しない。これをどうこうするのは無駄に面倒なので

メモ
//・連打制限?（前の入力から0.1秒以上は開けるようにする）

useridを
レート計算＝＞適当に画面側で固定の数値足したり引いたり
まず、planet scaleのDBに接続できることの確認

ネットワーク例外処理周り
・相手がいなくなったときの処理
・そもそも自分がサーバーに繋がらないとき

正解か不正解かは画面上で丸かバツかなどで分かるべき
user_guidが知られると困るのでそれぞれに返すboardの情報からuserguidを抜いて1か2で自分か相手かを意味するようにする
DB上にguidとレートを持ちたいがそうすると一気に価格が跳ね上がるのでどうするかな……
planetsearchでDB作ってみようと思う

CREATE TABLE `users` (
  `id` binary(16) NOT NULL PRIMARY KEY,
  `name` varchar(24) NOT NULL,
  `rate` INT
);

と、していたがplanet searchDBに接続するにはplanet search cliという
ソフトが必要で、、コンテナにそれをインストールすることができない以上無理。
したがって、azureのDBを使う方法を模索する
https://learn.microsoft.com/ja-jp/azure/cosmos-db/nosql/tutorial-nodejs-web-app

favicon.ico
https://icooon-mono.com/11343-%e3%83%aa%e3%82%b9%e3%81%ae%e3%82%a2%e3%82%a4%e3%82%b3%e3%83%b3%e3%81%a7%e3%81%99%e3%81%9f%e3%81%84%e3%80%82/


ボタンとニックネームに関しては横並びのが良かったので
直す



else if (data['mode'] === 'TurnMode') {
                    //TurnModeでゲーム開始した場合

                    //中断した部屋がなく開始の場合
                    socket.join('waitingroom_turn');
                    const clients = io.sockets.adapter.rooms.get('waitingroom_turn');
                    console.log('turnmode待機ルームの人のIDのセット', clients);
                    //to get the number of clients in this room
                    const numClients = clients ? clients.size : 0;

                    if (numClients > 1 && clients) {
                        //nagaiもし同時にたくさん人きたら誰か同時に入ってしまいそうなので
                        //判定処理は入れる、その部屋に入っている人の数を取得する
                        const clientsArr = Array.from(clients);
                        //idさえ分かれば誰でも入れるので、roomIdは推測不能な文字列に
                        const roomId = crypto.randomUUID();

                        const cl0 = io.sockets.sockets.get(clientsArr[0]);
                        const cl1 = io.sockets.sockets.get(clientsArr[1]);
                        if (cl0 && cl1) {
                            //待機ルームを抜けて対戦ルームに入る
                            cl0.leave('waitingroom_turn');
                            cl1.leave('waitingroom_turn');
                            cl0.join(roomId);
                            cl1.join(roomId);

                            //マッチ
                            //io.to(clientsArr[0]).emit('match', roomId);
                            //io.to(clientsArr[1]).emit('match', roomId);
                            cl0.emit('match', roomId);
                            cl1.emit('match', roomId);

                            if (cl0.data.pubUserId === cl1.data.pubUserId) {//同一ブラウザ同士の対決、もしく同一のpubUserId同士（不正に設定）の場合
                                cl0.data.matchUserId = cl0.data.subUserId;
                                cl1.data.matchUserId = cl1.data.subUserId;
                            }

                            const rclients = io.sockets.adapter.rooms.get(roomId);
                            console.log('ルーム:', roomId, 'に入っている人のIDのSet', rclients);
                            console.log('待機ルームの人のIDのSet', clients);
                            const rnumClients = clients ? clients.size : 0;
                            if (rnumClients > 2) {
                                //もし同じ部屋に二人以上入ってしまっていたら解散（そんなことがあるか分からないが）
                                cl0.leave(roomId);
                                cl1.leave(roomId);
                                cl0.join('waitingroom_turn');
                                cl1.join('waitingroom_turn');
                                console.log('解散 ルーム:', roomId, 'の人のIDのセット', rclients);
                                console.log('解散', '待機ルームの人のIDのセット', clients);
                            } else {
                                console.log('TurnModeゲーム開始');
                                //正常に部屋が立ったなら
                                //ゲームに必要な情報を作成する
                                //盤面の正解の情報,現在の盤面の状態
                                boards[roomId] = generateStartBoard(cl0.data.matchUserId, cl1.data.matchUserId, data['mode']);
                                const state = (({ board, points }) => { return { board, points } })(boards[roomId]);
                                io.to(roomId).emit("state", state);
                                socket.data.readBoard = structuredClone(state['board']);

                                //この後無限にカウントダウンが始まるようにする必要がある
                                const intervalid = setInterval(function () {
                                    boards[roomId]['countdown'] -= 1;
                                    io.to(roomId).emit("countdown", boards[roomId]['countdown']);
                                    if (boards[roomId]['countdown'] < 1) {
                                        clearInterval(intervalid);
                                        //nagai clearIntervalをするのはゲームが終了したとき…(or 1000カウントくらいに到達したら止める)
                                        //ここの処理でendgameを判定してclearintervalするか、intervalidをtableに入れてendgameの処理がされたときにclearとするか？
                                        //ここシームレスに処理を進めたくない。user1=>判定、どれもsubmitされなかったならランダムに一枚開く（不正解でも開かない）、=>プレイヤー交代
                                        //とする。……でも結局ここはずっと回し続ければいいだけかな
                                        //setintervalは処理が重いならそれぞれ同時に動いてしまうのでその点かなり注意して設計したい
                                    }
                                }, 1000);
                            }
                        }
                    }
                }

みすった……
pubUserIdに他人のものを入れた場合成り代わることができる。
成り代わるというのはrankingを自分のものにできるということ。
pubUserIdとuserIdで一意なものにすれば成り代わりは防げる。
別アカウント扱いにできる。
